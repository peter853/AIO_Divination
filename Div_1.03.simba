program AIO_Divination;
{$DEFINE SMART}
{$I SRL-6/SRL.simba}
{$I sps/sps-rs3.simba}
{$I div_include.simba}

var
  memoriesCon, eMemoriesCon, totalMem, totalEMem, wisp_TPA_timer: integer;
  mmCenter: TPoint;
  msBounds, mmBounds: TBox;
  wisp_TPA: TPointArray;


const
  SIPHON_PALE_WISPS = 0;
  SIPHON_FLICKERING_WISPS = 1;
  SIPHON_BRIGHT_WISPS = 2;
  SIPHON_GLOWING_WISPS = 3;
  SIPHON_SPARKLING_WISPS = 4;
  SIPHON_GLEAMING_WISPS = 5;
  SIPHON_VIBRANT_WISPS = 6;
  SIPHON_LUSTROUS_WISPS = 7;
  SIPHON_BRILLIANT_WISPS = 8;
  SIPHON_RADIANT_WISPS = 9;
  SIPHON_LUMINOUS_WISPS = 10;
  SIPHON_INCANDESCENT_WISPS = 11;

procedure declarePlayers;
begin
  setLength(players, 1);
  with players[0] do
  begin
    integers[0] := 2;//1, 2 or 3 memory conversion options
    integers[1]  := SIPHON_LUSTROUS_WISPS;//wisp name
    booleans[0] := true;//Are you gaining %10 extra exp because of boon?
    loginName   := 'log';
    bankPin     := '1234';
    password    := 'pass';
    isActive    := true;
    isMember    := true;
    world       := -1;
  end;
  currentPlayer := 0;
end;

procedure initInfo;
begin
  msBounds := mainscreen.getBounds;
  mmBounds := minimap.getBounds;
  mmCenter := minimap.getCenterPoint;
  init_div_include(players[currentPlayer].integers[1]);
end;

function rn(rand: integer = 0): integer;
begin
  result := randomRange(-1*rand, rand);
end;

function findWisp: TPoint;
var
  wisps: TPointArray;
  splitWisps: T2DPointArray;
  MSCenter: TPoint;
  i, h: integer;
begin
  result := [0, 0];
  MSCenter := [285, 200];
  if not findColorsTolerance(wisps, 14269045, msBounds, 8, colorSetting(2, 0.63, 4.17)) then exit;
  splitWisps := wisps.toATPA(15, 15);
  setLength(wisps, 0);
  h := high(splitWisps);

  for i := 0 to h do
    if length(splitWisps[i]) > 10 then insert(splitWisps[i].getMiddle, wisps);

  if length(wisps) <= 0 then exit;
  wisps.sortFromPoint(MSCenter);
  result := wisps[low(wisps)];
end;

function siphon: boolean;
var
  wisp: TPoint;
  i, threshold, speedMouse: integer;
begin
  threshold := getSystemTime + randomRange(200, 2000);
  result := tabBackpack.isFull;
  while (threshold > getSystemTime) do
  begin
    wait(randomRange(200, 400));
    if tabBackpack.isFull then exit(true);
    wisp := findWisp;
    if wisp.equals([0, 0]) then continue;
    speedMouse := mouseSpeed;
    mouseSpeed := mouseSpeed + randomRange(5, 15);
    mouse(wisp.rand(rn(2)), MOUSE_RIGHT, MOUSE_HUMAN);
    mouseSpeed := speedMouse;
    if chooseOption.select(['Harvest '], randomRange(2500,3500)) then exit(true);
  end;
end;

function energyColorCount: integer;
var
  yellowCount: TPointArray;
begin
  if findColors(yellowCount, 65535, tabBackpack.getSlotBox(1)) then
    result := length(yellowCount);
end;

function riftMM2: TPoint;
begin
  if not SPS_PosToMM(div_info.div_AIOInfo.rift_point, div_info.area_map.getPlayerPos, result) then
    result := [0, 0];
end;

function moveToRift: boolean;
begin
  result := div_info.area_map.blindWalk(div_info.div_AIOInfo.rift_point);
end;

function moveToWisps: boolean;
var
  index: integer;
  tempPoint: TPoint;
begin
  tempPoint := findWisp;
  if tempPoint.equals([0, 0]) then
  begin
    index := randomRange(low(div_info.div_AIOInfo.POIs), high(div_info.div_AIOInfo.POIs));
    result := div_info.area_map.blindWalk(div_info.div_AIOInfo.POIs[index]);
  end else result := true;
end;

procedure waitWhileSiphoning;
var
  threshold, invCount, yellowCount: integer;
  spinPoint: TPoint;
begin
  threshold := getSystemTime + randomRange(3000,4000);
  invCount := tabBackpack.count;
  yellowCount := energyColorCount;
  while threshold > getSystemTime do
  begin
    if findSpinTicket(spinPoint) then
      mouse(spinPoint.rand(rn(4)), Mouse_Left, Mouse_Human);
    if tabBackpack.isFull then exit;
    wait(randomRange(200, 500));
    if (invCount <> tabBackpack.count) or (yellowCount <> energyColorCount) then
    begin
      threshold := getSystemTime + randomRange(1800,2800);
      invCount := tabBackpack.count;
      yellowCount := energyColorCount;
    end;
  end;
end;

function collectMemories: boolean;
var
  threshold, noWisps: integer;
begin
  threshold := getSystemTime + randomRange(180000,270000);
  result := tabBackpack.isFull;
  while (threshold > getSystemTime) and (not result) do
  begin
    result := tabBackpack.isFull;
    if siphon then
    begin
      noWisps := 0;
      if minimap.isFlagPresent(randomRange(1500, 3000)) then
      minimap.waitFlag();
      waitWhileSiphoning;
    end else if not moveToWisps then exit;
    wait(randomRange(100,200));
  end;
end;

function riftMS: TPointArray;
var
  rifty: TPointArray;
  rifty2d: T2DPointArray;
  i, h: integer;
begin
  if not findColorsTolerance(rifty, 8447955, msBounds, 31) then exit;
  rifty2d := rifty.toATPA(15, 15);
  rifty2d.sortBySize();
  h := high(rifty2d);

  for i := 0 to high(rifty2d) do
    if length(rifty2d[i]) > 15 then
      insert(rifty2d[i].getMiddle, result);
end;

procedure convertOption;
begin
  typeSend(toString(players[CurrentPlayer].integers[0]), false);
end;

function riftOpen: boolean
var
  searchArea: TBox;
  whitePoints: TPointArray;
begin
  searchArea := [203, 66, 370, 84];
  findColors(whitePoints, 12378347, searchArea);
  result := inRange(length(whitePoints), 545, 555);
end;

function wait2Convert: boolean;
var
  threshold: integer;
begin
  threshold := getSystemTime + randomRange(6000, 10000);
  while (threshold > getSystemTime) and (not result) do
  begin
    result := riftOpen;
    wait(200);
  end;
  wait(randomRange(100, 400));
end;

procedure countMemories(var enriched, normal: integer);
var
  midColor, memSlots: TIntegerArray;
  grabPoint: TPoint;
  i, common, h: integer;
begin
  for i := 1 to 28 do
    if (countColor(ITEM_OUTLINE_BLACK, tabBackpack.getSlotBox(i)) = 73) then insert(i, memSlots);
  if length(memSlots) < 1 then exit;
  setLength(midColor, length(memSlots));
  enriched := 0;
  normal := 0;
  h := high(memSlots);
  for i := 0 to h do
  begin
    grabPoint := tabBackpack.getSlotBox(memSlots[i]).getMiddle;
    midColor[i] := getColor(grabPoint.x, grabPoint.y-9);
  end;
  common := midColor.getMostCommon;
  midColor.sortQuick;
  if (midcolor[0] = midColor[h]) then
  begin
    normal := length(memSlots);
    exit;
  end;
  for i := 0 to h do
    if (midColor[i] = common) then inc(normal) else inc(enriched);
end;

function countMemories: integer; overload;
var
  e, n: integer;
begin
  countMemories(e, n);
  result := e + n;
end;

function waitWhileConverting: boolean;
var
  threshold, invCount, invChange: integer;
begin
  threshold := getSystemTime + randomRange(45000,60000);
  invChange := getSystemTime + RandomRange(5000, 8000);
  invCount := tabBackpack.count;
  while (threshold > getSystemTime) and (countMemories > 0) do
  begin
    wait(250);
    if invCount <> tabBackpack.count then
    begin
      invCount := tabBackpack.count;
      invChange := getSystemTime + RandomRange(4000, 8000);
    end;
    if getSystemTime > invChange then exit;
  end;
  result := countMemories < 1;
  if result then wait(randomRange(50, 500));
end;

procedure printProgress;
var
  secondsElapsed, expPHour, totalEXP, wispEXP, eWispEXP, memEXP, eMemEXP: extended;
begin
  incEx(totalMem, memoriesCon);
  incEx(totalEMem, eMemoriesCon);
  wispEXP := totalMem * div_info.div_AIOInfo._wXP;
  eWispEXP := totalEMem * div_info.div_AIOInfo._ewXP;
  memEXP := totalMem * div_info.div_AIOInfo._mXP[players[CurrentPlayer].integers[0]];
  eMemEXP := totalEMem * div_info.div_AIOInfo._eXP[players[CurrentPlayer].integers[0]];
  totalEXP := wispEXP + eWispEXP + memEXP + eMemEXP;

  //add to total exp if using boon
  if players[CurrentPlayer].booleans[0] then totalEXP := totalEXP * 1.1;

  secondsElapsed := (getTimeRunning/1000);
  expPHour := (totalEXP * 60 * 60) / secondsElapsed;

  smartImage.clearArea(IntToBox(400, 515, 555, 578));
  smartImage.drawBox(IntToBox(400, 515, 555, 578), true, clOrange);
  smartImage.DrawText('Run Time: ' + msToTime(GetTimeRunning, TIME_SHORT), Point(400, 515), upchars, false, 2102790);
  smartImage.DrawText('EXP/Hour: ' + toString(round(expPHour)), Point(400, 525), upchars, false, 2102790);
  smartImage.DrawText('Total EXP: ' + toString(totalEXP), Point(400, 535), upchars, false, 2102790);
  smartImage.DrawText('Enriched Memories: ' + toString(totalEMem), Point(400, 545), upchars, false, 2102790);
  smartImage.DrawText('Regular Memories: '+toString(totalMem), Point(400, 555), upchars, false, 2102790);
  smartImage.DrawText('Harvesting '+ div_info.div_AIOInfo.wisp_name + ' wisps ', Point(400, 565), upchars, false, 2102790);
end;

function openRift: boolean;
var
  threshold: integer;
  MM_rift: TPoint;
  riftMSTPA: TPointArray;
  i: integer;
begin
  threshold := getSystemTime + randomRange(55000, 75000);
  while (threshold > getSystemTime) and (not result) do
  begin
    if riftOpen then exit(true);
    wait(randomRange(200, 400));
    riftMSTPA := riftMS;
    if length(riftMSTPA) < 1 then if not moveToRift then continue;
    for i := 0 to high(riftMSTPA) do
    begin
      mouse(riftMSTPA[i], Mouse_right, Mouse_Human);
      result := chooseOption.select(['Convert memories', 'memories En'], randomRange(3500,4500));
      if result then exit;
    end;
    moveToRift;
  end;
end;

function convertMemories: boolean;
var
  threshold: integer;
begin
  countMemories(eMemoriesCon, memoriesCon);
  if openRift then
  begin
    if wait2Convert then
    begin
      wait(randomRange(100,400));
      threshold := getSystemTime + randomRange(4000,7000);
      while (threshold > getSystemTime) and riftOpen do
      begin
        convertOption;
        wait(randomRange(300, 600));
      end;
    end;
    if (threshold > getSystemTime) and (not riftOpen) then
      result := waitWhileConverting;
    if result then printProgress;
  end;
  memoriesCon := 0;
  eMemoriesCon := 0;
end;

procedure mainLoop;
begin
  if (not isLoggedIn) and players[currentPlayer].isActive then
  begin
    if players[currentPlayer].login then
    begin
      wait(randomRange(200, 2000));
      minimap.clickCompass;
      wait(randomRange(200, 2000));
      mainscreen.setAngle(MS_ANGLE_HIGH);
      wait(randomRange(10, 2000));
    end else players.next(false);
  end;

  if not collectMemories then exit;
  if not convertMemories then exit;
  wait(randomRange(100,200));
end;

begin
  smartEnableDrawing := true;
  setupSRL;
  declarePlayers;
  initInfo;

  while players.getActive > 0 do mainLoop;
end.
